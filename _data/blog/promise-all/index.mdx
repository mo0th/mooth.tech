---
title: Write your own Promise.all()
tags:
  - javascript
  - typescript
category: 'javascript'
shortDescription: |
  Work your way up to the super useful Promise.all() function!

# createdAt: '2023-03-19'
# updatedAt: '2023-03-19'
---

<Note variant="info">
  This post works in TypeScript and JavaScript. If you don't know, or don't care
  about TypeScript you can toggle it: <TsJsToggle responsive={false} />, or most
  TypeScript / JavaScript code blocks.
</Note>

`Promise.all()` is a super useful function that takes a list of promises and
returns a promise that resolves to the results of each of the promises. Most
importantly, it returns the results of your promises **in the same order**, and
runs the promises concurrently.

<Image
  src="/img/promise-all/promise-all.png"
  width="2880"
  height="938"
  alt="depiction of Promise.all accepting a list of promises and return a promise resolving to the list with results in the order of the provided promises"
/>

## Getting started

To get started, we need a function that matches the signature of `Promise.all`,
i.e. one that accepts a list of promises and returns a promise. We're using the
Promise constructor here as it allows us to manually resolve the promise
whenever we want with its executor function. For now, we'll resolve the promise
immediately with an empty array and for the majority of the article we'll be
working out of the executor function.

```ts
type PromiseAllResult<Promises extends readonly unknown[] | []> = Promise<{
  -readonly [K in keyof Promises]: Awaited<Promises[K]>
}>

const myPromiseAll = <Promises extends readonly unknown[] | []>(
  promises: Promises
): PromiseAllResult<Promises> => {
  return new Promise((resolve, reject) => {
    resolve([] as unknown as PromiseAllResult<Promises>)
  })
}
```

<OnlyIsTs isTs>
  <Collapse summary="Explanation of complex types" summaryComponent="h3">
    The types above may seem overly complex, but they're required to make sure
    types _flow through_ the function, and give you a correctly type output and are . Here's
    my best attempt at an explanation of the more confusing parts:

    * We need a generic so that the output types can match the input types. The `Promises`
      type argument extends `readonly unknown[]` to ensure that the input is an array.
      We mark the array type as `readonly` as it allows the function's types to
      [work with a wider variety of inputs](https://www.typescriptlang.org/play?#code/MYewdgzgLgBATgUwIYBNwBsCeBBOcmYCMMAvDANqEA0MATALoxIQyiRQCwAUG9PMmjBZc+TLQBcMAEoCMOPAQA8YAK4BbAEYI4APlIVqdegG5u3XrDWYACnBBqAlhATZ06YmUW37ThCwQAHlAIYCgsMqhyIkoqYADWYCAA7mB6AD4U9DoAFNwwMAAOdo7OEJLeJX7cAJTlxb6KAN4wALSIkUKYFADSMA5gMHEImCAAZjAVvhD0kthJSA7BKF71peTdWTAAvnokeo15-FAqcAONW0wsSGCY3FtmXFaTzq7u2e2CwgpE1dxPqy43IR3rJOtExL8uA8LDB-j4Xm5aPoVvC-DBAsFQixYglkmByIwMgScociqiyhMARAanVUU1Wh85D0+gMhiNxs8-DMYHMFksUZUIOtNjtSPtDohjqcYOdLkwbnduAB6JUwAByIGCMCgAAsEOi8CA4Cw9Yg-jYAa9aCCOl9RIRIXDKlabZ95KJaNUgA).
      The additional `| []` allows the types of tuple elements to flow through the function
      too. Finally, we use `unknown` instead of `any` as it prevents us from accidentally
      making mistakes in the function body.
    * In the output type we use a [mapped type](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
      which allows for correct output types when using tuples. The `-readonly` in the mapped
      type makes the resulting type **not** readonly, and `Awaited` unwraps promise types,
      converted something like `Promise<number>` to `number`.

  </Collapse>
</OnlyIsTs>

Let's now extract out the results array so that we can easily set values in
later steps:

```ts
// ...
const results: PromiseAllResult<Promises> = []
resolve(results)
```

## The na√Øve approach

## Setting results in the right order

## Handling errors

## All together
